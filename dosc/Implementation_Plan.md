# Implementation Plan: Система анализа продаж

**Автор:** Левин Серафим, МОАИС-О-25/1
**Вариант:** 12 - Аналитика продаж  
**Дата создания:** 1 декабря 2025  
**Версия:** 1.2 (количество глобальных правок: 2)

---

## 1. Краткое описание задачи

Разработать консольное приложение на C++ для анализа данных о продажах, загружаемых из JSON-файлов. Программа должна выполнять валидацию входных данных, вычислять ключевые метрики (общая выручка, средний чек, топ товаров), группировать данные по датам и предоставлять отчёты в человекочитаемом виде с замерами производительности.

---

## 2. Цель и ожидаемый результат

### 2.1 Цель проекта
Создать полнофункциональную систему анализа продаж, демонстрирующую навыки работы с:
- Файловым вводом/выводом
- Ручным парсингом JSON
- Структурами данных (векторы, словари)
- Валидацией данных
- Алгоритмами обработки и агрегации
- Измерением производительности

### 2.2 Ожидаемые результаты

**На выходе пользователь получает:**
1. **Консольный отчёт** с форматированными таблицами, содержащий:
   - Общую статистику (количество заказов, общая выручка, средний чек)
   - Выручку по дням с разбивкой по датам
   - Топ-N товаров по выручке
   - Замеры времени работы по этапам

2. **Техническую документацию:**
   - Полный исходный код на C++ без внешних библиотек для JSON
   - Набор тестовых данных различного объёма (10 - 100,000 заказов)
   - Отчёт по бенчмаркам с выявленным узким местом
   - Предложения по оптимизации

3. **GitHub репозиторий** с:
   - Структурированной организацией кода
   - README с инструкциями
   - Примерами использования
   - Демонстрационными сценариями

---

## 3. Этапы и задачи реализации

### Этап 1: Анализ формата данных и проектирование (2 дня)

**Задачи:**
1. Изучить спецификацию JSON формата для данных о продажах
2. Определить структуры данных для представления:
   - Товара (артикул, количество, цена)
   - Заказа (ID, дата-время, список товаров)
   - Результатов анализа
3. Спроектировать минимальный парсер JSON:
   - Функции для чтения строк, чисел, объектов, массивов
   - Обработка экранированных символов (\", \\, \n)
4. Определить правила валидации данных

**Критерии готовности:**
- Документированы структуры `Item` и `Order`
- Определены функции парсинга
- Составлен список проверок валидации

---

### Этап 2: Реализация ввода и парсинга JSON (3-4 дня)

**Задачи:**
1. Реализовать функции чтения примитивов:
   - `skip_spaces()` - пропуск пробельных символов
   - `read_json_string()` - чтение строк в кавычках
   - `read_json_number()` - чтение чисел
2. Реализовать парсинг структур:
   - `read_json_item()` - парсинг товара из JSON-объекта
   - `read_json_order()` - парсинг заказа с массивом товаров
   - `read_json()` - парсинг массива заказов
3. Реализовать загрузку файла:
   - Открытие файла через `ifstream`
   - Чтение всего содержимого в строку
   - Обработка ошибок открытия файла
4. Добавить первичную обработку ошибок парсинга

**Критерии готовности:**
- Программа успешно парсит корректные JSON-файлы
- Выводятся понятные сообщения об ошибках парсинга
- Код покрывает все поля структур

---

### Этап 3: Валидация входных данных (2 дня)

**Задачи:**
1. Реализовать функцию `check_orders()` с проверками:
   - ID заказа не пустой
   - Дата в корректном формате (длина >= 10 символов)
   - В заказе есть хотя бы один товар
   - Артикул товара не пустой
   - Количество товара > 0
   - Цена товара >= 0
2. Добавить подробные сообщения об ошибках:
   - Указание номера заказа
   - Указание номера товара в заказе
   - Описание конкретной проблемы
3. Реализовать подсчёт общего количества ошибок
4. Остановка анализа при наличии ошибок

**Критерии готовности:**
- - Все типы ошибок корректно обнаруживаются
- - Сообщения об ошибках информативны
- - Программа не падает на некорректных данных

---

### Этап 4: Реализация вычислений и алгоритмов (4-5 дней)

**Задачи:**
1. Основные расчёты:
   - `calculate_order_total()` - стоимость заказа
   - `calculate_average_check()` - средний чек
   - Подсчёт общей выручки
   - Подсчёт общего количества товаров
2. Группировка данных:
   - `get_date()` - извлечение даты из timestamp
   - `calculate_daily_revenue()` - выручка по дням с использованием `std::map`
3. Анализ товаров:
   - `find_top_products()` - топ-N товаров по выручке
   - Агрегация выручки по артикулам в `std::map`
   - Сортировка результатов (пузырьковая сортировка для демонстрации узкого места)
4. Оптимизация памяти:
   - Использование const-ссылок для больших структур
   - Избегание лишних копирований

**Критерии готовности:**
- - Все расчёты дают корректные результаты
- - Группировка по датам работает правильно
- - Топ товаров определяется корректно

---

### Этап 5: Вывод результатов и UX консоли (2 дня)

**Задачи:**
1. Реализовать форматированный вывод:
   - `print_line()` - печать разделительных линий
   - `print_header()` - печать заголовков секций
   - `print_money()` - форматирование денежных сумм (2 знака после запятой)
2. Создать структурированные отчёты:
   - Общая статистика с выравниванием колонок
   - Таблица выручки по дням
   - Таблица топ товаров с нумерацией
3. Реализовать интерфейс командной строки:
   - Флаги `--help`, `--input`, `--top`
   - Краткие аналоги: `-h`, `-i`, `-t`
   - Справка по использованию
4. Обработка ошибок пользовательского ввода:
   - Проверка наличия обязательных параметров
   - Понятные сообщения об ошибках

**Критерии готовности:**
- - Вывод читаемый и структурированный
- - Таблицы выровнены
- - CLI работает интуитивно
- - Справка информативна

---

### Этап 6: Измерение производительности (2 дня)

**Задачи:**
1. Добавить замеры времени с `std::chrono`:
   - Время загрузки файла
   - Время парсинга JSON
   - Время валидации данных
   - Время расчётов и агрегации
2. Вывести детальный отчёт по времени работы:
   - Время каждого этапа в миллисекундах
   - Общее время выполнения
   - Процентное соотношение этапов
3. Провести предварительные бенчмарки:
   - На файлах разного размера (10, 100, 1k, 10k заказов)
   - Зафиксировать результаты

**Критерии готовности:**
- - Замеры времени работают корректно
- - Вывод времени интегрирован в отчёт
- - Есть предварительные данные по производительности

---

### Этап 7: Генератор тестовых данных (2-3 дня)

**Задачи:**
1. Создать отдельную программу `generate_data.cpp`:
   - Генерация случайных артикулов
   - Генерация случайных дат в заданном диапазоне
   - Генерация товаров с разными ценами и количеством
   - Генерация заказов с переменным количеством товаров
2. Реализовать режимы генерации:
   - Корректные данные разных объёмов
   - Данные с намеренными ошибками для тестирования валидации
3. Создать пресеты:
   - Малые файлы: 10, 100, 1000 заказов
   - Большие файлы: 10k, 50k, 100k заказов
   - Файлы с ошибками: 50, 500 заказов
4. Добавить CLI для генератора

**Критерии готовности:**
- - Генератор создаёт валидный JSON
- - Данные разнообразны и реалистичны
- - Ошибочные данные покрывают все типы ошибок
- - Созданы все необходимые наборы данных

---

### Этап 8: Тестирование и отладка (3 дня)

**Задачи:**
1. Функциональное тестирование:
   - Корректность расчётов на известных данных
   - Работа валидации на ошибочных данных
   - Граничные случаи (пустые файлы, 1 заказ, очень большие числа)
2. Тестирование производительности:
   - Запуск на всех размерах данных
   - Выявление узкого места
   - Анализ причин низкой производительности
3. Тестирование UX:
   - Все флаги командной строки работают
   - Сообщения об ошибках понятны
   - Вывод корректно форматируется
4. Создание тестовых сценариев:
   - Позитивные тесты (корректные данные)
   - Негативные тесты (ошибочные данные)
   - Граничные случаи

**Критерии готовности:**
- - Найдены и исправлены все критические баги
- - Программа стабильно работает на всех тестах
- - Задокументированы результаты тестов

---

### Этап 9: Оптимизация и попытка улучшения (2 дня)

**Задачи:**
1. Анализ профилирования:
   - Определение самой медленной функции
   - Измерение времени её работы отдельно
2. Предложение оптимизаций:
   - Замена пузырьковой сортировки на `std::sort`
   - Использование `std::partial_sort` для топ-N
   - Резервирование памяти для векторов
3. Реализация одной оптимизации:
   - Создание оптимизированной версии функции
   - Сравнительные бенчмарки
4. Документирование результатов:
   - Описание проблемы
   - Предложенное решение
   - Измеренное улучшение

**Критерии готовности:**
- - Узкое место чётко идентифицировано
- - Реализована минимум 1 оптимизация
- - Есть сравнительные замеры "до" и "после"

---

### Этап 10: Документация и оформление (2-3 дня)

**Задачи:**
1. Создать структуру GitHub репозитория:
   ```
   /src          - исходный код
   /data         - примеры JSON
   /docs         - документация
   /tests        - тестовые сценарии
   /scripts      - вспомогательные скрипты
   ```
2. Написать README.md:
   - Описание проекта
   - Инструкции по сборке и запуску
   - Примеры использования
   - Демонстрационный сценарий
3. Создать docs/bench.md:
   - Методика проведения бенчмарков
   - Таблицы с результатами измерений
   - Графики (опционально)
   - Анализ узкого места
   - Предложения по оптимизации
4. Подготовить Implementation_Plan.md (этот документ)
5. Создать .gitignore для C++
6. Сделать осмысленные коммиты
7. Создать Pull Request для демонстрации code review

**Критерии готовности:**
- - Репозиторий имеет правильную структуру
- - README полный и понятный
- - Документация по бенчмаркам подробная
- - Git история аккуратная

---

## 4. План-график

| Этап | Название | Длительность | Сроки | Статус |
|------|----------|--------------|-------|--------|
| 1 | Анализ формата и проектирование | 2 дня | 1-2 дек | Завершён |
| 2 | Реализация парсинга JSON | 3-4 дня | 3-6 дек | Завершён |
| 3 | Валидация данных | 2 дня | 7-8 дек | Завершён |
| 4 | Вычисления и алгоритмы | 4-5 дней | 9-13 дек | Завершён |
| 5 | Вывод результатов и UX | 2 дня | 14-15 дек | Завершён |
| 6 | Измерение производительности | 2 дня | 16-17 дек | Завершён |
| 7 | Генератор тестовых данных | 2-3 дня | 18-20 дек | Завершён |
| 8 | Тестирование и отладка | 3 дня | 21-23 дек | В процессе |
| 9 | Оптимизация | 2 дня | 24-25 дек | Запланировано |
| 10 | Документация и оформление | 2-3 дня | 26-28 дек | Запланировано |

**Общая длительность:** ~3-4 недели  
**Планируемая дата завершения:** 28 декабря 2024  
**Резерв времени:** 3 дня на непредвиденные сложности

---

## 5. Ресурсы

### 5.1 Технические средства

**Язык программирования:**
- C++17 или выше, используется С++20
- Стандартная библиотека (STL)
- Без внешних библиотек для JSON-парсинга

**Среда разработки:**
- IDE: VS Code / Cursor с расширением CLion
- Компилятор: g++ (GCC) / clang
- Система контроля версий: Git
- Хостинг кода: GitHub

**Библиотеки и заголовки:**
- `<iostream>` - ввод/вывод
- `<fstream>` - работа с файлами
- `<string>` - строки
- `<vector>` - динамические массивы
- `<map>` - словари для группировки
- `<chrono>` - замеры времени
- `<random>` - генератор данных
- `<iomanip>` - форматирование вывода

### 5.2 Данные и спецификации

**Формат входных данных:**
```json
[
  {
    "id": "string",
    "ts": "string (ISO 8601)",
    "items": [
      {
        "sku": "string",
        "qty": "number (>0)",
        "price": "number (>=0)"
      }
    ]
  }
]
```

**Тестовые наборы данных:**
- `sales_10.json` - 10 заказов (~3 KB)
- `sales_100.json` - 100 заказов (~30 KB)
- `sales_1000.json` - 1,000 заказов (~300 KB)
- `sales_10k.json` - 10,000 заказов (~3 MB)
- `sales_50k.json` - 50,000 заказов (~15 MB)
- `sales_100k.json` - 100,000 заказов (~30 MB)
- `sales_errors_small.json` - 50 заказов с ошибками
- `sales_errors_medium.json` - 500 заказов с ошибками

### 5.3 Документация и материалы

**Официальная документация:**
- [C++ Reference](https://en.cppreference.com/) - справочник по C++
- [JSON.org](https://www.json.org/) - спецификация JSON
- [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) - формат даты-времени

**Учебные материалы:**
- Курс "Поколение" по C++ - базовые концепции
- Методические материалы по работе с файлами
- Примеры парсинга JSON вручную

**Инструменты:**
- [JSONLint](https://jsonlint.com/) - валидация JSON
- Valgrind (опционально) - проверка утечек памяти
- GDB (опционально) - отладка

---

## 6. Риски и их митигация

| Риск | Вероятность | Влияние | Митигация |
|------|-------------|---------|-----------|
| Ошибки парсинга сложных JSON | Средняя | Высокое | Тщательное тестирование на разных форматах |
| Низкая производительность на больших данных | Высокая | Среднее | Планирование времени на оптимизацию |
| Утечки памяти | Низкая | Среднее | Использование RAII, проверка с Valgrind |
| Недостаток времени | Средняя | Высокое | Резерв 3 дня, упрощение опциональных функций |

---

## 7. Критерии успеха проекта

Проект считается успешно завершённым, если:

1. - Программа компилируется без ошибок и предупреждений
2. - Корректно парсит все тестовые JSON-файлы
3. - Валидация обнаруживает все типы ошибок
4. - Все расчёты дают правильные результаты
5. - CLI работает интуитивно, есть справка
6. - Вывод структурирован и читаем
7. - Замеры времени показывают реальную производительность
8. - Узкое место идентифицировано и задокументировано
9. - Есть попытка оптимизации с измеренным эффектом
10. - Документация полная и понятная
11. - GitHub репозиторий правильно структурирован
12. - Есть демонстрационный сценарий работы

---

## 8. Заключение

Данный план реализации охватывает все ключевые аспекты разработки системы анализа продаж: от проектирования структур данных до финальной документации. Особое внимание уделено качеству кода, надёжности, производительности и пользовательскому опыту.

План разбит на 10 последовательных этапов с чёткими критериями готовности, что позволяет отслеживать прогресс и своевременно выявлять проблемы. Предусмотрено время на тестирование, оптимизацию и документирование, что обеспечит высокое качество итогового продукта.

---

**Подпись:** Левин Серафим, МОАИС-О-25/1
**Дата:** 1 декабря 2025
